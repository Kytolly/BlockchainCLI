## 区块链期末项目

* 以《区块链基本原型》和《区块链工作量证明》这两结课讨论的代码为基础，并结合《区块链数据格式规范》进一步完善区块链的区块底层数据结构（交易数据构成的默克尔树结构）。
* 结合《区块链与密码学》中讨论的区块链密码学技术，采用公钥密码学，完成区块链账号和交易相关数据结构设计的基础上，实现交易数据私钥签名后，发送给区块链节点，区块链节点采用链上公钥进行验证后，写入区块；
* 实现交易在区块上的查询，通过默克尔树验证某一笔交易是否存在于某一个区块上。

## 2024.9.21:完成了对基本区块链结构的设计

### 日期时间
2024.9.21 23：00

### 任务概述

- [x] 完成`block`的基本设计
- [x] 完成`BlockChain`的基本设计

### 任务描述
完成了`internal/model/block`的基本设计

* 其中`Block`中包括字段`Timestamp`、`Data`、`PreviousHash`、`Hash`；
  * `Timestamp`是当前时间戳（创建区块时）；
  * `Data`是区块中包含的实际有价值的信息；
  * `PreviousHash`存储前一个区块的哈希值
  * `Hash`是区块的哈希值
  * 在Botcoin规范中，区块由`Header`和`Transactions`序列组成，其中`Header`包括`{timestamp, nonce, version, previousHash, difficulty, merkel root}`组成，**简单起见上述设计，后面按需更改**；
* 其中`BlockChain`由`Block`形成的数组组成；从设计的本质上讲，区块链只是一个具有特定结构的数据库：它是一个有序的反向链接列表。这意味着块按插入顺序存储，并且每个块都链接到前一个块。这种结构允许快速获取链中的最新区块，并（有效地）通过其哈希值获取区块，**通常由数组和映射来实现**，数组由`hash`值构成，映射到对应区块；但是对于demo来说并不需要从 `hash->block`;注意这里的`blocks`字段应该为私有；
* 建立函数`SetHash()`，哈希的计算方式是区块链非常重要的特性，正是这个特性使区块链安全。这里计算`Hash`使用`sha256`算法；
* 实现`NewBlock()`, 这里进行字符串的拼接获得`Hash`值，这样的区块简单又便宜,  后续将实现 **工作量证明机制**使得添加新块变得困难，防止新块添加后遭到篡改；
* 实现`AddBlock()`，向其中添加块；
* 实现创世块`NewGenesisBlock()`
* 实现`NewBlockChain()`通过创世块建立区块链；
* 完成测试文件`block_test.go`编写,测试建立了一个简单的只有3个块的区块链；
* 完成测试脚本`auto_test.sh`关于model的测试部分，**注意没有报错机制**，需要仔细检查输出是否有报错；

### 下一步的计划
- [ ] 完成工作量证明的基本设计
- [ ] 设计区块头
- [ ] 设计区块数据为真正的交易序列
- [ ] 设计`BlockChain`可以实现从`Hash`到`Block`的映射；
- [ ] 设计`Shell`测试文件的报错标红



## 2024.9.23：完成了工作量证明设计
### 日期时间
2024.9.23 1：00

### 任务概述

- [x] 完成工作量证明的基本设计
- [x] 完成部分工具包函数的编写
- [x] 设计区块头

### 任务描述

* 


### 下一步的计划

- [ ] 完成日志包的编写与测试
  1. 实现日志等级；
  2. 实现文件记录；
  3. 实现控制台记录
- [ ] 设计`BlockChain`可以实现从`Hash`到`Block`的映射；
- [ ] 设计`Shell`测试文件的报错标红
- [ ] 完成`BlockHeader`的提前设计`Version, MerkleRoot, Difficuly`的字段；
- [ ] 补充`HashCash`的文档；
- [ ] 设计挖矿难度根据目标调整算法
- [ ] 持久化区块链数据库
- [ ] 设计钱包
- [ ] 设计地址
- [ ] 设计交易
- [ ] 设计共识机制

## 2024.9.23：持久化连接数据库+区块链迭代器

### 日期时间

2024.9.23 12：30

### 任务概述

- [ ] 持久化区块链数据库

### 任务描述

* 确定如何在 DB 中存储数据

  * 参考`bitcioin`规范：`blocks`存储描述链中所有区块的元数据，`chainstate`存储链的状态，即所有当前未使用的交易输出和一些元数据。

* 对`Block`进行序列化,以及实现反序列化

* 修改`BlockChain{tip, db}`:我们不再将所有区块都存储在其中，而**只存储链的尖端**。此外，我们还存储 DB 连接，因为**我们希望打开它一次，并在程序运行时保持打开状态**。

* 修改`NewBlockchain()`的逻辑如下：

  1. 打开一个 DB ；
  2. 检查其中是否存储了区块链
  3. 如果有区块链：创建新的`BlockChain`实例，将实例的 tip 设置为存储在 DB 中的最后一个数据块哈希值；
  4. 如果没有现有的区块链：
     * 创建创世区块
     * 存储在DB中
     * 将创世区块的哈希值保存为最后一个区块哈希值
     * 创建一个新实例，其尖端指向创世区块。
  5. 更新方法`AddBlock`,我们在DB中存储区块


### 下一步的计划

- [ ] 完成日志包的编写与测试
  1. 实现日志等级；
  2. 实现文件记录；
  3. 实现控制台记录
- [ ] 设计`BlockChain`可以实现从`Hash`到`Block`的映射；
- [ ] 设计`Shell`测试文件的报错标红
- [ ] 完成`BlockHeader`的提前设计`Version, MerkleRoot, Difficuly`的字段；
- [ ] 补充`HashCash`的文档；
- [ ] 设计挖矿难度根据目标调整算法
- [ ] 设计钱包
- [ ] 设计地址
- [ ] 设计交易
- [ ] 设计共识机制
- [ ] 命令行参数解析和界面设计
- [ ] 数据库生产，开发环境配置隔离

## 2024.9.24:完成对区块链数据库持久化的测试

### 日期时间

2024.9.24 3：30

### 任务概述

- [ ] 完成对区块链迭代器的设计
- [ ] 实现数据库的持久化
- [ ] 对关键信息打印日志
- [ ] 完成对`cli`的设计
- [ ] 完成`main.go`

### 任务描述

* 迭代器设计为`{bc:BlockChain}`用于接管对区块链的操作；
* 实现了`addblock,printchain`的操作

### 下一步的计划

- [ ] 完成日志包的编写与测试
  1. 实现日志等级；
  2. 实现文件记录；
  3. 实现控制台记录
- [ ] 设计`BlockChain`可以实现从`Hash`到`Block`的映射；
- [ ] 完成`BlockHeader`的提前设计`Version, MerkleRoot, Difficuly`的字段；
- [ ] 补充`HashCash`的文档；
- [ ] 设计挖矿难度根据目标调整算法
- [ ] 设计钱包
- [ ] 设计地址
- [ ] 设计交易
- [ ] 设计共识机制
- [ ] 数据库生产，开发环境配置隔离ini

## 2024.9.25: 生产，开发配置环境隔离，实现日志，补充文档

### 日期时间

2024.9.24 3：30

### 任务描述

* 实现日志管理
* 实现数据库生产，开发环境配置隔离ini
* 修复`printchain`的迭代失败的`bug`
* 补充`HashCash`的文档；

### 下一步的计划

- [ ] 设计`BlockChain`可以实现从`Hash`到`Block`的映射；

- [ ] 完成`BlockHeader`的提前设计`Version, MerkleRoot, Difficuly`的字段；

- [ ] 设计挖矿难度根据目标调整算法

- [ ] 设计钱包

- [ ] 设计地址

- [ ] 设计交易

- [ ] 设计共识机制

  
